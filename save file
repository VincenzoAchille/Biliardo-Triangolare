void ball::ballDynamicsAnimated(float v) {
    float t{0};
    float T{0};
    float h{0};
    sf::RenderWindow window(sf::VideoMode(static_cast<unsigned int>(m_window.x), static_cast<unsigned int>(m_window.y)), "Biliardo Triangolare");
    window.setFramerateLimit(60);  //questo per qualche motivo va ad uniformare la velocitÃ  della build con quellla del g++
    sf::CircleShape shape1(ball::getRadius());
    shape1.setOrigin(m_radius, m_radius);
    shape1.setPosition(m_center.x, m_center.y - m_y);
    shape1.setFillColor(sf::Color::Cyan);
    for (int i{0}; i >= 0; i++) {
    bool selectedMotion = this->isColliding();
    sf::Vector2f impact;
    if (selectedMotion == 1) {
      ball toUpdate(m_x, m_y, m_m, m_direction);
      toUpdate.collisionPosition();
      impact.x = toUpdate.getX();
      impact.y = toUpdate.getY();
    } else {
      if (m_direction > 0) {
        impact.x = positionX(m_l);
        impact.y = positionY(m_l);
      } else {
        impact.x = positionX(0);
        impact.y = positionY(0);
      }
    }
    if (m_direction < 0) {
      T = h;
      t = 0;
    }
    
    while (window.isOpen()) {
      if (m_direction > 0) {
        h = t;
      } else {
        h = T - t;
      }
      sf::Event event;
      while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed) window.close();
      }
      
      
      float scale = 1.0f / std::sqrt(1 + m_m * m_m);
      float effective_t = h*v;
      float angle = std::abs(std::atan(m_m));
      shape1.setPosition(m_center.x + positionX(effective_t),
                         m_center.y - positionY(effective_t));
      

      float newX = positionX(effective_t);
      float newY = positionY(effective_t);

      window.clear();
      window.draw(upperBound());
      window.draw(lowerBound());
      window.draw(shape1);
      

      window.display();
      bool isCollision =
          std::abs((newX + sgn(m_direction) * m_radius * std::cos(angle)) -
                   impact.x) < m_errorTolerance &&
          std::abs((newY + sgn(normal())*sgn(m_r1-m_r2) * m_radius * std::sin(angle)) -
                   impact.y) < m_errorTolerance;
    

      float yFinalCollision;
      float xFinalCollision;
      if (m_direction > 0) {
        yFinalCollision = m_m * (m_l - m_x) + m_y;
        xFinalCollision = m_l;
      } else {
        yFinalCollision = -m_m * m_x + m_y;
        xFinalCollision = 0.f;
      }
      bool finalCollision;
      if (m_direction > 0) {
        finalCollision =
            std::abs(newX - m_l) < m_errorTolerance && std::abs(newY - yFinalCollision) < m_errorTolerance;
      } else {
        finalCollision =
            std::abs(newX - 0.) < m_errorTolerance && std::abs(newY - yFinalCollision) < m_errorTolerance;
      }
      std::cout << "newX: " << newX << ", " << "newY: " << newY << '\n';
      std::cout << "newX: " << impact.x << ", " << "newY: " << impact.y << '\n';
      if (selectedMotion && isCollision) {
        //std::cout << std::atan(m_m) << '\n';
        std::cout << "urto avvenuto" << '\n';
        update(newX, newY);
        //std::cout << "X= " << m_x << " Y= " m_y << " M = " << '\n';
        //update(impact.x - sgn(m_direction) * m_radius * std::cos(angle), impact.y - sgn(normal())*sgn(m_r1-m_r2) * m_radius * std::sin(angle));
        //std::cout << "X= " << m_x << " Y= " m_y << " M = " << '\n';
       
        break;
      } else if (!selectedMotion && finalCollision) {
        
        ball bTemp (xFinalCollision,yFinalCollision,m_m,m_direction);
        *this = bTemp;
        while (window.isOpen()) {
          sf::Event event2;
          while (window.pollEvent(event2)) {
            if (event2.type == sf::Event::Closed) {
              window.close();
              return;
            }

            if (event2.type == sf::Event::KeyPressed) {
              if (event2.key.code == sf::Keyboard::Escape) {
                window.close();
                return;
              }
            }
          }
          window.clear();
          window.draw(upperBound());
          window.draw(lowerBound());
          window.draw(shape1);
          window.display();
        }

      }

      else {
        t = t + scale;
      }
    }
  }
}
