void ball::ballDynamicsAnimated(float v) {
  float time{0};
  float lastCollisionX{0};
  float positionX{0};
  sf::RenderWindow window(sf::VideoMode(static_cast<unsigned int>(m_window.x),
                                        static_cast<unsigned int>(m_window.y)),
                          "Biliardo Triangolare");
  window.setFramerateLimit(60);
  sf::CircleShape circleShape(ball::getRadius());
  circleShape.setOrigin(m_radius, m_radius);
  circleShape.setPosition(m_center.x, m_center.y - m_y);
  circleShape.setFillColor(sf::Color::Cyan);
  while (true) {
    const bool collide = isColliding();
    sf::Vector2f impactCoordinates;
    if (collide) {
      ball toUpdate(*this);
      toUpdate.nextCollisionPosition();
      impactCoordinates.x = toUpdate.getX();
      impactCoordinates.y = toUpdate.getY();
    } else {
      if (m_direction > 0) {
        impactCoordinates.x = m_l;
        impactCoordinates.y = positionY(m_l);
      } else {
        impactCoordinates.x = 0.f;
        impactCoordinates.y = positionY(0);
      }
    }
    if (m_direction < 0) {
      lastCollisionX = positionX;
      time = 0;
    }

    while (window.isOpen()) {
      if (m_direction > 0) {
        positionX = time;
      } else {
        positionX = lastCollisionX - time;
      }
      sf::Event event;
      while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed) window.close();
      }

      const float scale = 1.0f / std::sqrt(1 + m_m * m_m);
      const float effectivePositionX = positionX * v;
      const float angle = std::abs(std::atan(m_m));
      circleShape.setPosition(m_center.x + effectivePositionX,
                              m_center.y - positionY(effectivePositionX));

      float newY = positionY(effectivePositionX);
      window.clear();
      window.draw(upperBound());
      window.draw(lowerBound());
      window.draw(circleShape);

      window.display();
      bool isCollision =
          std::abs((effectivePositionX +
                    sgn(m_direction) * m_radius * std::cos(angle)) -
                   impactCoordinates.x) < m_errorTolerance &&
          std::abs((newY + sgn(normal()) * sgn(m_r1 - m_r2) * m_radius *
                               std::sin(angle)) -
                   impactCoordinates.y) < m_errorTolerance;

      float yFinalCollision;
      float xFinalCollision;
      if (m_direction > 0) {
        yFinalCollision = m_m * (m_l - m_x) + m_y;
        xFinalCollision = m_l;
      } else {
        yFinalCollision = -m_m * m_x + m_y;
        xFinalCollision = 0.f;
      }
      bool finalCollision;
      if (m_direction > 0) {
        finalCollision =
            std::abs(effectivePositionX - m_l) < m_errorTolerance &&
            std::abs(newY - yFinalCollision) < m_errorTolerance;
      } else {
        finalCollision = std::abs(effectivePositionX - 0.) < m_errorTolerance &&
                         std::abs(newY - yFinalCollision) < m_errorTolerance;
      }

      if (collide && isCollision) {
        update(effectivePositionX, newY);

        break;
      } else if (!collide && finalCollision) {
        ball bTemp(xFinalCollision, yFinalCollision, m_m, m_direction);
        *this = bTemp;
        while (window.isOpen()) {
          sf::Event event2;
          while (window.pollEvent(event2)) {
            if (event2.type == sf::Event::Closed) {
              window.close();
              return;
            }

            if (event2.type == sf::Event::KeyPressed) {
              if (event2.key.code == sf::Keyboard::Escape) {
                window.close();
                return;
              }
            }
          }
          window.clear();
          window.draw(upperBound());
          window.draw(lowerBound());
          window.draw(circleShape);
          window.display();
        }

      }

      else {
        time = time + scale;
      }
    }
  }
}